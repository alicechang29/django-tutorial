from django.shortcuts import render, get_object_or_404
from django.db.models import F
from django.http import HttpResponseRedirect
from django.urls import reverse
from django.utils import timezone
from django.views import generic
# django has generic template views (ListView, DetailView, etc)

from .models import Question, Choice
# Create your views here.


# Each generic view needs to know what model it will be acting upon.
# This is provided using either the model attribute (model = Question)
# or by defining the get_queryset() method (as shown in IndexView).

class IndexView(generic.ListView):
    template_name = "polls/index.html"
    context_object_name = "latest_question_list"
    # specifies what list to use. Django defaults to question_list

    def get_queryset(self):
        """Return the last 5 published questions"""
        # Question.objects.filter(pub_date__lte=timezone.now())
        # returns a queryset containing Questions whose pub_date is less than or equal to - that is, earlier than or equal to - timezone.now.
        return Question.objects.filter(pub_date__lte=timezone.now()).order_by("-pub_date")[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = "polls/detail.html"
    # template_name attribute is used to tell Django to use a specific
    # template name instead of the autogenerated default template name.

    def get_queryset(self):
        """
        Excludes any questions that aren't published yet.
        """
        # __lte = less than or equal to, __gte, __lt, __gt (greater than)
        return Question.objects.filter(pub_date__lte=timezone.now())


class ResultsView(generic.DetailView):
    model = Question
    template_name = "polls/results.html"
    # setting different template_name than DetailView so there is diff appearance
    # when rendered even if using same template

# What's happening under the hood...
# def detail(request, question_id):
#     question = get_object_or_404(Question, pk=question_id)
#     return render(request, "polls/detail.html", {"question": question})


def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        # request.Post['choice'] - access obj by key name
        # in this case, returns id of the choice as a string
        # request.Post values always STRINGS
        selected_choice = question.choice_set.get(pk=request.POST["choice"])
    except (KeyError, Choice.DoesNotExist):
        return render(
            request,
            "polls/detail.html",
            {"question": question,
             "error_message": "You didn't select a choice."
             }
        )
    else:
        # Django uses the F() object to generate an SQL expression that describes the required operation at the database level.
        # Have DB perform operation instead of Python doing it: https://docs.djangoproject.com/en/5.0/ref/models/expressions/#avoiding-race-conditions-using-f
        selected_choice.votes = F("votes") + 1
        selected_choice.save()

        # reverse() returns "/polls/3/results/"
        # forward direction is url --> view
        # reverse() is: give Django the name of a view, and Django generates the appropriate url. view name --> url
        return HttpResponseRedirect(reverse("polls:results", args=(question.id,)))
